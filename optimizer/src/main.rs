use std::{fs, collections::{HashMap, LinkedList, HashSet, BTreeMap}, env, time::SystemTime, io::Write};
use constraint_list::constraint_simplification;
use num_bigint_dig::BigInt;
use circom_algebra::algebra::Constraint;




fn read_auto_generated( line : Option<&str>) -> bool{
    if line.is_none() || !line.expect("").eq("; Auto generated by ZoKrates") {
        println!("ERROR. Expected first sentence: Auto generated by ZoKrates");
        return false
    }
    return true
}

fn write_witness(hmap : BTreeMap<usize, BigInt>){
    let mut file = fs::File::create("witness.json").unwrap();
    file.write(b"[").unwrap();
    let mut first_time = true;
    for (a,b) in hmap.clone(){
        if first_time{
            file.write(b"\"").unwrap();
            first_time = false;
        }
        else{
            file.write(b",\"").unwrap();
        }
        file.write(b.to_string().as_bytes()).unwrap();
        file.write(b"\"\n").unwrap();
    }
    file.write(b"]").unwrap();
}

fn read_circuit_variables( line : Option<&str>) -> Option<usize> {
    let num_circuit_variables : usize;
    if line.is_none() {
        println!("ERROR. Expected second sentence: ; Number of circuit variables: XXX");
        return None;
    }
    else {
        let line_vars = line.expect("");
        let ls : Vec<&str> = line_vars.split(":").collect();
        if ls.len() != 2 || !ls[0].eq("; Number of circuit variables"){
            println!("ERROR. Expected second sentence: ; Number of circuit variables: XXX");
            return None;
        }
        num_circuit_variables = ls[1].trim().parse().expect("ERROR. A number of circuit variables was expected");
    }
    return Some(num_circuit_variables);
}

fn  read_number_equalities( line : Option<&str>) -> Option<usize> {
    let num_equalities : usize;
    if line.is_none() {
        println!("ERROR. Expected second sentence: ; Number of equalities: XXX");
        return None;
    }
    else {
        let line_vars = line.expect("");
        let ls : Vec<&str> = line_vars.split(":").collect();
        if ls.len() != 2 || !ls[0].eq("; Number of equalities"){
            println!("ERROR. Expected second sentence: ; Number of equalities: XXX");
            return None;
        }
        num_equalities = ls[1].trim().parse().expect("ERROR. A number of equalities was expected");
    }
    return Some(num_equalities);
}

fn read_witness(file : &String, signal_to_label : HashMap<&str, usize>) -> BTreeMap<usize,BigInt>{
    let mut hmap = BTreeMap::new();
    let contents = fs::read_to_string(file).expect("File not found");
    let mut opt_line = contents.lines();
    let mut next_line = opt_line.next();
    while !next_line.is_none(){
        let ls : Vec<&str> = next_line.expect("No problem").split(" ").collect();
        if ls.len() != 2 {
            println!("{}",next_line.expect(".").clone());
        }
        else{
            let coeff : BigInt = ls[1].trim().parse().unwrap(); 
            let coeff2 = coeff.clone();
            hmap.insert(signal_to_label[ls[0].trim()], coeff2);
        }
        next_line = opt_line.next();
    }

    //serde_json::to_writer(file, &hmap).unwrap();
    hmap
}

fn main() {
    // --snip--
    let args: Vec<String> = env::args().collect();
    let filename = &args[1];
    let simplified_or_not = & args[2];
    let apply_non_linear_simplification : bool = simplified_or_not.eq("simplified");
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");
    /*let mut opt1_line = contents.lines();
    let mut contents2 : String = "".to_string();
    let mut check_line = opt1_line.next();
    while !check_line.is_none() {
        if !check_line.unwrap().is_empty() {
            contents2.push_str(check_line.unwrap());
            contents2.push_str("\n");
        }
        check_line = opt1_line.next();
    }*/
    let mut forb = HashSet::new();
    let mut opt_line = contents.lines();
    let zokrates_line = opt_line.next();
    if !read_auto_generated(zokrates_line) {return;}

    let circuit_variables_line = opt_line.next();
    let mut num_circuit_variables = 0;
    match read_circuit_variables(circuit_variables_line){
        Some(value) => {num_circuit_variables = value;},
        None => {return;},
    }

    let number_equalities_line = opt_line.next();
    let mut num_equalities = 0;
    match read_number_equalities(number_equalities_line){
        Some(value) => {num_equalities = value;},
        None => {return;},
    }

    println!("Number of circuit variables and equalities is {} and {}, respesctively.", num_circuit_variables, num_equalities);
    println!("_prime and _one are considering to circuit variables corresponding to the prime number used and the signal for constants.");
    let mut it = 0;
    let mut label = 1;
    let num_var_out = 0;
    let mut varhm : HashMap<&str,usize> = HashMap::new();
    let ignored_line = opt_line.next(); /*We ignore ~prime*/
    //println!("IGNORO:{}",ignored_line.unwrap());
    while it <  num_circuit_variables {
        let line = opt_line.next().unwrap();
        //println!("LEO:{}",line);
        if line.contains("(declare-const"){
            let varstr : &str = process_declare_const(line);
            if varstr.eq("~one"){
                varhm.insert(varstr,0);
            }
            else if !varstr.eq("~prime"){
                if varstr.contains("out") {
                    forb.insert(label);
                }
                varhm.insert(varstr, label);
                label = label + 1;
            }
            it = it +1 ;
        }
        else{
        //    println!("Ignoring var num. {}", i);
        }
    }
    println!("TERMINA DE LEER LAS DECLARE-CONST");
    /* Let us ignore the line "(assert (and" */
    opt_line.next();
    let mut j = 0;
    /* We always have two first constraint regarding the |_prime| and |_one|, let us ignore them for now.*/
    let field_line = opt_line.next().unwrap();  
    let (_equaal2,_var_prime,prime) = break_in_three(field_line);
    let prime_field : BigInt = prime.trim().parse().unwrap();
    opt_line.next();

    let mut ll = LinkedList::new();
    while j < num_equalities {
        let line = opt_line.next();
        if !line.unwrap().is_empty() && !line.unwrap().eq("))"){
            let c = read_constraint(line.expect("ERROR. IT MUST BE A LINE."),&prime_field, & varhm);
            ll.push_back(c);
            j = j + 1;
        }
        if line.unwrap().eq("))"){
            j = num_equalities;
        }

    }
    /* Let us ignore the last line " )) " */
    opt_line.next();



    let max_signal = num_circuit_variables;
    let no_labels = num_circuit_variables;

    println!("TERMINA DE LEER TODAS LAS CONSTRAINTS");

    let reading_witness = & args[3];
    let witness = read_witness(reading_witness, varhm);
    println!("PUBLICAS: {}", forb.len());        
    let now = SystemTime::now();
    generate_storage_and_simplify(ll, forb, no_labels, max_signal,  prime_field, apply_non_linear_simplification, witness);
    let dur = now.elapsed().unwrap().as_millis();
    println!("SIMPLIFICATION  was performed in {} ms", dur);
 }

fn read_constraint (line : &str, prime_field : &BigInt, max : & HashMap<&str,usize>) -> Constraint<usize> {// Constraint<usize> {
    let (equual,a_b_mod, c_mod) = break_in_three(line);
    //println!("Constraint: {}", line);
    if !equual.eq("="){
        println!("PROBLEM");
        return Constraint::new(HashMap::new(), HashMap::new(), HashMap::new())
    }
    let (moduule,a_b, _prime) = break_in_three(a_b_mod);
    let (_moduule2,c, _prime2) = break_in_three(c_mod);
    
    if !moduule.eq("mod") || !moduule.eq("mod"){
        println!("PROBLEM");
        return Constraint::new(HashMap::new(), HashMap::new(), HashMap::new())
    }
    let (_prod,a, b) = break_in_three(a_b);

    //println!("A: {}",a);
    let a_hp = create_constraint(a, & max);

    //println!("B: {}",b);
    let b_hp = create_constraint(b, & max);
    
    //println!("C: {}",c);
    let c_hp = create_constraint(c, & max);

    /* 
    let x_c = BigInt::from(1);
    let y_c = BigInt::from(1);
    let constant_c = BigInt::from(4);
    let a = HashMap::new();
    let b = HashMap::new();
    let mut c = HashMap::new();

    */
    /*c.insert(x, x_c);
    c.insert(y, y_c);
    c.insert(constant, constant_c);*/
    let mut constraint = Constraint::new(a_hp, b_hp, c_hp);
    Constraint::fix_normalize_constraint(& mut constraint,prime_field);
    /*println!("This is A:");
    for c2 in constraint.a().clone(){
                 println!("     Signal: {:}",c2.0);
                 println!("     Value : {:}",c2.1.to_string());
             }
    println!("This is B:");
    for c2 in constraint.b().clone(){
                println!("     Signal: {:}",c2.0);
                println!("     Value : {:}",c2.1.to_string());
    }
    println!("This is C:");
    for c2 in constraint.c().clone(){
                println!("     Signal: {:}",c2.0);
                println!("     Value : {:}",c2.1.to_string());
    }*/
    return constraint;
}

fn var_to_int(line : & str, map : & HashMap<&str,usize>) -> usize{
    if line.eq("one"){
      return 0;
    }
    else if line.contains("out_"){
        let mut s1 : String = "~".to_owned();
        s1.push_str(line);
        let s2 : &str = &s1;
        let signal : usize = map[s2];
        return  signal;
    }
    else {
        let _expected_int : usize = line.parse().expect("ERROR");
        let mut s1 : String = "_".to_owned();
        s1.push_str(line);
        let s2 : &str = &s1;
        let signal : usize = map[s2];
        return  signal;
    }
}

fn process_declare_const(line : &str) -> &str{
    let ls : Vec<&str> = line.split("|").collect();
    return ls[1];
}

 fn create_constraint(line : &str, max : & HashMap<&str,usize>) -> HashMap<usize,BigInt>{
    let mut pol = HashMap::new();
    let  a_ls : Vec<&str> = line.split(" ").collect();
    let mut i = 0;
    while i < a_ls.len()  {
        if a_ls[i].eq("(*"){
            let var = &a_ls[i+1][2..a_ls[i+1].len()-1];
            let coeff : BigInt = a_ls[i+2].replace(")", "").parse().expect("ERROR");
            pol.insert(var_to_int(var, & max),coeff.clone());
            //println!(" {} : {}",var, coeff);
             i = i +3;
        }
        else{    i = i +1;
        }
    }
    return pol
}
 

fn break_in_three (line : &str) -> (&str,&str,&str){
    let fl_off: &str = &line[1..line.len() - 1];
    let ops : Vec<&str> = fl_off.split(" ").collect();
    let op = ops[0];
    let l = &fl_off[fl_off.find(" ").expect("NO PROBLEM")+1..fl_off.len()];
    let mut count_par = 0;
    let mut count = 1;
    match l.find("(") {
        Some(first_bracket) => {
            if l[first_bracket..first_bracket+1].eq("("){
                count_par += 1;
            }
            else{
                println!("ERROR");
            }
            while count_par > 0 && count < l.len(){
                if l[count..count+1].eq("("){
                    count_par += 1;
                }
                if l[count..count+1].eq(")"){
                    count_par -= 1;
                }
                count = count + 1;
            }
            let second = &l[0..count];
            let third = &l[count..l.len()];
            (op,second,third)
          }
        None => {    
            let m = l.find(" ").expect("It should be a number");
            (op,&l[0..m],&l[m..l.len()])
        }
    }
}


type SignalMap = HashMap<usize, usize>;
pub struct ConstraintList {
    pub field: BigInt,
    pub no_public_inputs: usize,
    pub no_public_outputs: usize,
    pub no_private_inputs: usize,
    pub constraints: circom_algebra::constraint_storage::ConstraintStorage,
    pub no_labels: usize,
    //  Signals in [witness_len, Vec::len(&signal_map)) are the ones deleted
    pub signal_map: SignalMap,
}

pub fn generate_storage_and_simplify(constraints: LinkedList<Constraint<usize>>, forb: HashSet<usize>, no_labels: usize, max_signal: usize,  field: BigInt, apply_simp: bool,
                                      witness: BTreeMap<usize, BigInt>){
    let mut linear = LinkedList::new();
    let mut storage = circom_algebra::constraint_storage::ConstraintStorage::new();
    for constraint in constraints{
        if Constraint::is_linear(&constraint) {
            linear.push_back(constraint);
        } else {
            storage.add_constraint(constraint);
        }
    }
    let (signalmap,witness) = constraint_list::constraint_simplification::simplification(linear, & mut storage, forb, no_labels, max_signal,  field.clone(), apply_simp, witness);
    let cl = constraint_list::r1cs_porting::ConstraintList{
        field : field,
        constraints : storage,
        no_public_inputs : 0,
        no_public_outputs : 0,
        no_private_inputs : 0,
        no_labels : no_labels,
        signal_map : signalmap
    };   
    write_witness(witness);
    constraint_list::r1cs_porting::port_r1cs(&cl,"a.r1cs");
}